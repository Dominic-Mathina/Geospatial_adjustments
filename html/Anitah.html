
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Anitah</title><meta name="generator" content="MATLAB 8.3"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2016-03-24"><meta name="DC.source" content="Anitah.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><pre class="codeinput"><span class="comment">% CODE DONE BY CHERONO ANITAH</span>
<span class="comment">% REG NO: F19/1705/2013</span>
</pre><p>file reader to read observations from excel sheet</p><pre class="codeinput">data=xlsread(<span class="string">'Data.xlsx'</span>);
 rdQ=data(:,1);
 rdF=data(:,2);
</pre><pre class="language-matlab"><span class="keyword">for</span> loop that <span class="string">reads</span> <span class="string">values</span> <span class="string">of</span> <span class="string">X</span> <span class="string">that</span> <span class="string">are</span> <span class="string">greater</span> <span class="string">than</span> <span class="string">zero</span>
</pre><pre class="codeinput"><span class="keyword">for</span> x = 1:length(rdQ);

    <span class="keyword">if</span> (rdQ(x)&gt;0);
        P(x)=rdQ(x);
    <span class="keyword">end</span>
<span class="keyword">end</span>
X=P';
</pre><pre class="language-matlab"><span class="keyword">for</span> loop that <span class="string">reads</span> <span class="string">values</span> <span class="string">of</span> <span class="string">Y</span> <span class="string">that</span> <span class="string">are</span> <span class="string">greater</span> <span class="string">than</span> <span class="string">zero</span>
</pre><pre class="codeinput"> <span class="keyword">for</span> y= 1:length(rdF)
     <span class="keyword">if</span> (rdF(y)&gt;0)
        U(y)= rdF(y);
      <span class="keyword">end</span>
 <span class="keyword">end</span>
Y=U';
</pre><p>loading other observations into the program</p><pre class="codeinput">DR=data(:,3);
DIST=data(:,4);
Sp=data(:,5);
Tp=data(:,6);
STW=data(:,7);
Spd=data(:,8);
Tpd=data(:,9);
<span class="comment">% error of 0.008 is introduced to observaion 1</span>

Dist=[(DIST(1,1)+0.008);data(2:6,4)];
</pre><p>conversion of grades to radians</p><pre class="codeinput">DRrad = degtorad(DR * (360/400));
</pre><p>for loop to perform 50 iterations</p><pre class="codeinput"> <span class="keyword">for</span> i=1:50;
</pre><pre class="codeinput"><span class="comment">% A matrix for distances</span>
       <span class="keyword">for</span> i = 1:6;
           s = Sp(i);
           t = Tp(i);
           dx = X(t)-X(s);
           dy = Y(t)-Y(s);
           Sc=sqrt(power(dx,2) +power(dy,2));
           j = 2*s-1 ;
           A1(i,j) = -dx/Sc;
           A1(i,j+1)= -dy/Sc;

           j = 2*t-1;
           A1(i,j) = dx/Sc;
           A1(i,j+1) = dy/Sc ;
           ds(i) = DIST(i) - Sc;

       <span class="keyword">end</span>
      dst = ds';
</pre><p>A matrix for directions</p><pre class="codeinput">   <span class="keyword">for</span> i = 1:49;
</pre><pre class="codeinput">       k = Spd(i);
       h = Tpd(i);
       deltax = X(h)-X(k);
       deltay = Y(h)-Y(k);
       ss = sqrt(deltax^2+deltay^2);
       j2 = 2*k-1;
       A2(i,j2) = deltay/(ss^2);
       A2(i,j2+1)= -deltax/(ss^2);

       j2=2*h-1;
       A2(i,j2) = -deltay/(ss^2);
       A2(i,j2+1)= deltax/(ss^2);
</pre><p>an if else statement to align the 'deltas'to respective quadrants</p><pre class="codeinput">         j2=1;
    <span class="keyword">if</span> ((deltax&gt;0) &amp;&amp;(deltay&gt;0));
        theta(i) = atan (abs(deltay/deltax));
    <span class="keyword">elseif</span> ((deltax&lt;0) &amp;&amp; (deltay&gt;0));
        theta(i) = pi -(atan (abs(deltay/deltax)));
    <span class="keyword">elseif</span> ((deltax&lt;0) &amp;&amp; (deltay&lt;0));
        theta(i) = atan (abs(deltay/deltax)) + pi;
    <span class="keyword">else</span> ((deltax&gt;0) &amp;&amp; (deltay&lt;0));
        theta(i) = (2*pi)-atan (abs(deltay/deltax));
    <span class="keyword">end</span>
</pre><pre class="codeinput">    <span class="comment">%for loop for the swing to be applied to the observation directions</span>
       <span class="keyword">for</span> i=1:11;j=1;
        C(i,j) = atan((Y(2,1)-Y(1,1))/(X(2,1)-X(1,1)));
        i=12:22;j=1;
        C(i,j) = atan((Y(1,1)-Y(2,1))/(X(1,1)-X(2,1))) + pi;
        i = 23:33;j=1;
        C(i,j) = atan((Y(3,1)-Y(1,1))/(X(3,1)-X(1,1))) + pi;
        i= 34:44;
        C(i,j) = atan((Y(4,1)-Y(1,1))/(X(4,1)-X(1,1))) + pi;
        i = 45:49 ;
        C(i,j) = atan((Y(5,1)-Y(1,1))/(X(5,1)-X(1,1))) ;
        L=DRrad+C;
       <span class="keyword">end</span>
</pre><pre class="codeinput">   <span class="keyword">end</span>
</pre><p>L matrix to orient the observations</p><pre class="codeinput"> <span class="keyword">for</span> ii=1:length(L) ;
  <span class="keyword">if</span> (L(ii)&gt;0 &amp; L(ii)&lt;=pi);
          Or(ii) = L(ii);
<span class="comment">%          disp(L(ii))</span>
        <span class="keyword">elseif</span> (L(ii)&lt;=1.5*pi &amp; L(ii)&gt;pi );
         Or(ii) =  L(ii);
<span class="comment">%            disp(L(ii))</span>
        <span class="keyword">elseif</span> (L(ii)&lt;=2*pi  &amp; L(ii)&gt;1.5*pi);
           Or(ii) = L(ii);
<span class="comment">%          disp(L(ii))</span>
        <span class="keyword">elseif</span> (L(ii)&gt;2*pi)
          Or(ii) = L(ii)-2*pi;
<span class="comment">%           disp(L(ii)-2*pi)</span>
        <span class="keyword">else</span> (L(ii)&lt;=0);
         Or(ii) = L(ii) + 2*pi;
 <span class="comment">%           disp(L(ii) + 2*pi)</span>
   <span class="keyword">end</span>
 <span class="keyword">end</span>
   Theta1=theta';
   Dir_observed = Or';
   dL = Dir_observed - Theta1;

   dlf=[dst;dL];
</pre><p>The nuisance parameters for drections</p><pre class="codeinput">    <span class="keyword">for</span> i =1:11; j=1;
       WN(i,j) =1;
       i= 12:22; j=2;
       WN(i,j) =1;
       i = 23:33; j=3;
       WN(i,j) =1;
       i= 34:44;  j=4;
       WN(i,j) =1;
       i = 45:49; j=5;
       WN(i,j) =1;
    <span class="keyword">end</span>
</pre><pre class="codeinput"><span class="comment">%At is a matrix of non-coordinates(nuisance parameters)</span>
<span class="comment">% Ax matrix of type coordinates</span>
 At=[zeros(6,5);WN];
 Ax=[A1 zeros(6,16);A2];
</pre><p>weight matrices of the observations(directions &amp; distances respectively)</p><pre class="codeinput">  <span class="keyword">for</span> i=1;j=1:49;
      W1(i,j)=(4.25451703*10^10);

  <span class="keyword">end</span>
   W2=[zeros(49,6) diag(W1)];


  <span class="keyword">for</span> i= 1;j=1:6;
      W3(i,j)=11111111.11;

  <span class="keyword">end</span>
   W4 =[diag(W3) zeros(6,49)];
</pre><p>combined weight matrix</p><pre class="codeinput">   W5=[W4;W2];
</pre><p>combined  A matrix type coordinates and non coordinates</p><pre class="codeinput">  AF=[Ax At];
<span class="comment">%  computing Normal equation matrix</span>
  N = AF'*W5*AF;
</pre><pre class="language-matlab">individual <span class="string">elements</span> <span class="string">to</span> <span class="string">make</span> <span class="string">up</span> <span class="string">the</span> <span class="string">Normal</span> <span class="string">euation</span> <span class="string">matrix</span>
</pre><pre class="codeinput">  Axx=Ax'*W5*Ax;
  Att=At'*W5*At;
  Atx=At'*W5*Ax;
  Axt=Ax'*W5*At;
<span class="comment">%combined normal equatin matrix</span>
 NAxt=[Axx Axt;Atx Att];
</pre><p>reduced normal equation matrix</p><pre class="codeinput"> N_x=Axx-((Axt*inv(Att))*Atx) ;
<span class="comment">% absolute vector of type coordinates</span>
 nx=Ax'*W5*dlf;
<span class="comment">%  absolute vector of type non coordinates</span>
 nt=At'*W5*dlf;
<span class="comment">%  reduced absolte vector</span>
 n_x = nx-(Axt*(inv(Att))*nt);
</pre><pre class="language-matlab"><span class="keyword">for</span> loop to <span class="string">form</span> <span class="string">the</span> <span class="string">G-matrix</span> <span class="string">for</span> <span class="string">free</span> <span class="string">network</span> <span class="string">adjustment</span>
</pre><pre class="codeinput"><span class="keyword">for</span> i=1;j=1:2:24;
      G(i,j)=1;
      i=2;j=2:2:24;
      G(i,j)=1;
       i=3;j=1:2:24;
      G(i,j)= Y;
      j=2:2:24;
      G(i,j)= -X;

<span class="keyword">end</span>
</pre><p>forming the constraint matrix R</p><pre class="codeinput">R=[N_x G';G zeros(3,3)];
<span class="comment">% final reduced absolute vector with correct dimensions</span>
 n_xx=[n_x ;zeros(3,1)];
<span class="comment">%  computing the corrections</span>
 dxf=inv(R)*n_xx;
</pre><pre>seperating individual corrections in X and Y</pre><pre class="codeinput">  <span class="keyword">for</span> j=1;
      i=1:2:24;
      dx1=dxf(i);
      i=2:2:24;
     dy1=dxf(i);
  <span class="keyword">end</span>
</pre><p>X and Y coordinates of points after adjustment</p><pre class="codeinput">X=X+dx1;
Y=Y+dy1;
</pre><pre class="codeinput"> <span class="keyword">end</span><span class="comment">%%</span>
<span class="comment">%computing the residual vectors v</span>
dX1=[dxf;zeros(2,1)];
 A_x=AF*dX1;
 v=dlf-A_x;

<span class="comment">%  end of the iteration loop</span>

<span class="comment">%  inverse of the constraint matrix R</span>
IR=inv(R);
Qxx=IR(1:24,1:24);
<span class="comment">% aposteriori variance sigma</span>
sigma=(v'*W5*v)/(55-24);
<span class="comment">% perform Global Model Test GMM</span>
 GMM=(v'*W5*v);
<span class="comment">%  Compute the covriance matrix</span>
 Exx=sigma*Qxx;
<span class="comment">%  Extracting covariance matrices associated with the 12 points</span>
  E1 = diag(Exx);
  E2 = diag(Exx,1);
</pre><pre>a for loop extracting the variances from the above matrix</pre><pre class="codeinput"> <span class="keyword">for</span> j=1;
     i=1:2:24;
     sigx2=(E1(i));
     i1=1:2:23;
     Covarx = (E2(i1));
      i1=1:2:23;
     i=2:2:24;
     Covary = (E2(i1));
     sigy2= (E1(i));
 <span class="keyword">end</span>
</pre><p>obtaining elements of the error ellipses</p><pre class="codeinput"> sigx=sqrt(sigx2);
 sigy=sqrt(sigy2);
 a=sqrt((0.5*(sigx2+sigy2))+sqrt(0.25*(sigx2-sigy2)).^2+Covarx.^2);
 b=sqrt((0.5*(sigx2+sigy2))-sqrt(0.25*(sigx2-sigy2)).^2+Covarx.^2);
</pre><pre>computation of the direction of semi-major axes</pre><pre class="codeinput">     <span class="keyword">for</span> i = 1:12;
         j=1;
        tanthita(i) = (2*Covarx(i))/(sigx2(i)-sigy2(i));
     <span class="keyword">end</span>
        thita = (atan(tanthita)/2)';
</pre><pre class="codeinput">     <span class="comment">%plotting error ellipses</span>
     <span class="keyword">for</span> i = 1:12;
            x=X(i);
            y=Y(i);
            grid <span class="string">on</span>;
            hold <span class="string">on</span>;
            plot(x,y);
     <span class="keyword">end</span>
    xlabel(<span class="string">'X coordinates'</span>);
    ylabel(<span class="string">'Y coordinates'</span>);
    title(<span class="string">'ERROR ELLIPSES'</span>);

    <span class="keyword">for</span> i = 1:49;
         p = X(Spd(i));
         g = X(Tpd(i));
         q = Y(Spd(i));
         r = Y(Tpd(i));
         x0 = [p g];
         y0 = [q r];
         plot(y0,x0);

    <span class="keyword">end</span>
<span class="comment">%     controlling the size of the ellipses</span>
    <span class="keyword">for</span> i = 1:12;
        p = 1:1:12;
        t = -2*pi:pi/100:2*pi;
        x = X(i)+((a(i)*sin(t))*25000);
        y = Y(i)+((b(i)*cos(t))*25000);
        plot(y,x);
        text(Y(i),X(i),num2str(i));
    <span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="Anitah_01.png" alt=""> <p>computing the test statistics T</p><pre class="codeinput"> T=v'*W5*v

 <span class="keyword">if</span> (T&lt;47.6 &amp; T &gt;16.1680)
  disp(<span class="string">'Accept the null hypothesis'</span>)
<span class="keyword">else</span>
  disp(<span class="string">'Reject the null hypothesis'</span>)
 <span class="keyword">end</span>

<span class="comment">%Computing the standard deviation of the residuals</span>


   vmean= (sum(v))/55;
  vsq= power(v-vmean,2);
Sd = sqrt((sum(vsq))/55);
<span class="comment">%  Outlier detection by method of outliers</span>
<span class="keyword">for</span> jj= 1:length(v);
  <span class="keyword">if</span> (v(jj) &lt;= 3*Sd)
    p(jj) = 1;
  <span class="keyword">elseif</span> (v(jj) &gt; 3*Sd)
    p(jj) = exp(-v(jj));
  <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><pre class="codeoutput">
T =

   42.8580

Accept the null hypothesis
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2014a</a><br></p></div><!--
##### SOURCE BEGIN #####
% CODE DONE BY CHERONO ANITAH
% REG NO: F19/1705/2013
%%
% file reader to read observations from excel sheet
data=xlsread('Data.xlsx');
 rdQ=data(:,1);
 rdF=data(:,2);
%% 
%   for loop that reads values of X that are greater than zero
for x = 1:length(rdQ); 
    
    if (rdQ(x)>0); 
        P(x)=rdQ(x);
    end 
end
X=P';
%% 
%   for loop that reads values of Y that are greater than zero
 for y= 1:length(rdF)
     if (rdF(y)>0)
        U(y)= rdF(y);
      end
 end
Y=U';
%% 
% loading other observations into the program
DR=data(:,3);                       
DIST=data(:,4);
Sp=data(:,5);
Tp=data(:,6);
STW=data(:,7);
Spd=data(:,8);
Tpd=data(:,9);
% error of 0.008 is introduced to observaion 1

Dist=[(DIST(1,1)+0.008);data(2:6,4)];
%% 
% conversion of grades to radians
DRrad = degtorad(DR * (360/400));
%% 
% for loop to perform 50 iterations
 for i=1:50;
% A matrix for distances 
       for i = 1:6;
           s = Sp(i);
           t = Tp(i);
           dx = X(t)-X(s);
           dy = Y(t)-Y(s);
           Sc=sqrt(power(dx,2) +power(dy,2));
           j = 2*s-1 ;
           A1(i,j) = -dx/Sc;
           A1(i,j+1)= -dy/Sc;
   
           j = 2*t-1;
           A1(i,j) = dx/Sc;
           A1(i,j+1) = dy/Sc ; 
           ds(i) = DIST(i) - Sc;

       end
      dst = ds';
%%         
% A matrix for directions
   for i = 1:49;
       k = Spd(i);
       h = Tpd(i);
       deltax = X(h)-X(k);
       deltay = Y(h)-Y(k);
       ss = sqrt(deltax^2+deltay^2);
       j2 = 2*k-1;
       A2(i,j2) = deltay/(ss^2);
       A2(i,j2+1)= -deltax/(ss^2);
       
       j2=2*h-1;
       A2(i,j2) = -deltay/(ss^2);
       A2(i,j2+1)= deltax/(ss^2);
%% 
% an if else statement to align the 'deltas'to respective quadrants
         j2=1;
    if ((deltax>0) &&(deltay>0));
        theta(i) = atan (abs(deltay/deltax));
    elseif ((deltax<0) && (deltay>0));
        theta(i) = pi -(atan (abs(deltay/deltax)));
    elseif ((deltax<0) && (deltay<0));
        theta(i) = atan (abs(deltay/deltax)) + pi;
    else ((deltax>0) && (deltay<0));
        theta(i) = (2*pi)-atan (abs(deltay/deltax));
    end
%%     
   
    %for loop for the swing to be applied to the observation directions
       for i=1:11;j=1;
        C(i,j) = atan((Y(2,1)-Y(1,1))/(X(2,1)-X(1,1)));
        i=12:22;j=1;
        C(i,j) = atan((Y(1,1)-Y(2,1))/(X(1,1)-X(2,1))) + pi;
        i = 23:33;j=1;
        C(i,j) = atan((Y(3,1)-Y(1,1))/(X(3,1)-X(1,1))) + pi;
        i= 34:44;
        C(i,j) = atan((Y(4,1)-Y(1,1))/(X(4,1)-X(1,1))) + pi;
        i = 45:49 ;
        C(i,j) = atan((Y(5,1)-Y(1,1))/(X(5,1)-X(1,1))) ; 
        L=DRrad+C; 
       end 
   end 
%% 
% L matrix to orient the observations
 for ii=1:length(L) ;
  if (L(ii)>0 & L(ii)<=pi);
          Or(ii) = L(ii);
%          disp(L(ii))
        elseif (L(ii)<=1.5*pi & L(ii)>pi );
         Or(ii) =  L(ii);
%            disp(L(ii))
        elseif (L(ii)<=2*pi  & L(ii)>1.5*pi);
           Or(ii) = L(ii);
%          disp(L(ii))
        elseif (L(ii)>2*pi)
          Or(ii) = L(ii)-2*pi;
%           disp(L(ii)-2*pi)
        else (L(ii)<=0);
         Or(ii) = L(ii) + 2*pi;
 %           disp(L(ii) + 2*pi)
   end
 end
   Theta1=theta';
   Dir_observed = Or';
   dL = Dir_observed - Theta1;
   
   dlf=[dst;dL];
%%   
% The nuisance parameters for drections 
    for i =1:11; j=1;
       WN(i,j) =1;
       i= 12:22; j=2;
       WN(i,j) =1;
       i = 23:33; j=3;
       WN(i,j) =1;
       i= 34:44;  j=4;
       WN(i,j) =1;
       i = 45:49; j=5;
       WN(i,j) =1;
    end
%% 
%At is a matrix of non-coordinates(nuisance parameters)
% Ax matrix of type coordinates
 At=[zeros(6,5);WN];
 Ax=[A1 zeros(6,16);A2];
%%  
% weight matrices of the observations(directions & distances respectively)
  for i=1;j=1:49;
      W1(i,j)=(4.25451703*10^10);
     
  end
   W2=[zeros(49,6) diag(W1)];
  

  for i= 1;j=1:6;
      W3(i,j)=11111111.11;
     
  end
   W4 =[diag(W3) zeros(6,49)];
%%  
% combined weight matrix
   W5=[W4;W2];
%%   
% combined  A matrix type coordinates and non coordinates
  AF=[Ax At];
%  computing Normal equation matrix
  N = AF'*W5*AF;
%%   
%   individual elements to make up the Normal euation matrix
  Axx=Ax'*W5*Ax;
  Att=At'*W5*At;
  Atx=At'*W5*Ax;
  Axt=Ax'*W5*At;
%combined normal equatin matrix
 NAxt=[Axx Axt;Atx Att];
%% 
% reduced normal equation matrix
 N_x=Axx-((Axt*inv(Att))*Atx) ;  
% absolute vector of type coordinates
 nx=Ax'*W5*dlf;
%  absolute vector of type non coordinates
 nt=At'*W5*dlf;
%  reduced absolte vector
 n_x = nx-(Axt*(inv(Att))*nt);
%%  
%   for loop to form the G-matrix for free network adjustment
for i=1;j=1:2:24;
      G(i,j)=1;
      i=2;j=2:2:24;
      G(i,j)=1;
       i=3;j=1:2:24;
      G(i,j)= Y;
      j=2:2:24;
      G(i,j)= -X;
               
end
%% 
% forming the constraint matrix R
R=[N_x G';G zeros(3,3)];
% final reduced absolute vector with correct dimensions 
 n_xx=[n_x ;zeros(3,1)];
%  computing the corrections
 dxf=inv(R)*n_xx;
%%  
%  seperating individual corrections in X and Y
  for j=1;
      i=1:2:24;
      dx1=dxf(i);
      i=2:2:24;
     dy1=dxf(i);
  end
%%   
% X and Y coordinates of points after adjustment
X=X+dx1;
Y=Y+dy1;
 end%% 
%computing the residual vectors v
dX1=[dxf;zeros(2,1)];
 A_x=AF*dX1;
 v=dlf-A_x;

%  end of the iteration loop
 
%  inverse of the constraint matrix R
IR=inv(R);
Qxx=IR(1:24,1:24);
% aposteriori variance sigma
sigma=(v'*W5*v)/(55-24);
% perform Global Model Test GMM
 GMM=(v'*W5*v);
%  Compute the covriance matrix
 Exx=sigma*Qxx;
%  Extracting covariance matrices associated with the 12 points
  E1 = diag(Exx);
  E2 = diag(Exx,1);
%%   
%  a for loop extracting the variances from the above matrix
 for j=1;
     i=1:2:24;
     sigx2=(E1(i));
     i1=1:2:23;
     Covarx = (E2(i1));
      i1=1:2:23;
     i=2:2:24;
     Covary = (E2(i1));
     sigy2= (E1(i));
 end
%%  
% obtaining elements of the error ellipses
 sigx=sqrt(sigx2);
 sigy=sqrt(sigy2);
 a=sqrt((0.5*(sigx2+sigy2))+sqrt(0.25*(sigx2-sigy2)).^2+Covarx.^2);
 b=sqrt((0.5*(sigx2+sigy2))-sqrt(0.25*(sigx2-sigy2)).^2+Covarx.^2);
%%  
%  computation of the direction of semi-major axes
     for i = 1:12;
         j=1;
        tanthita(i) = (2*Covarx(i))/(sigx2(i)-sigy2(i));
     end
        thita = (atan(tanthita)/2)';
%%         
     %plotting error ellipses
     for i = 1:12;
            x=X(i);
            y=Y(i);
            grid on;
            hold on;
            plot(x,y);
     end
    xlabel('X coordinates');
    ylabel('Y coordinates');
    title('ERROR ELLIPSES');
    
    for i = 1:49;
         p = X(Spd(i));
         g = X(Tpd(i));
         q = Y(Spd(i));
         r = Y(Tpd(i));
         x0 = [p g];
         y0 = [q r];
         plot(y0,x0); 
        
    end
%     controlling the size of the ellipses
    for i = 1:12;
        p = 1:1:12;
        t = -2*pi:pi/100:2*pi;
        x = X(i)+((a(i)*sin(t))*25000);
        y = Y(i)+((b(i)*cos(t))*25000);
        plot(y,x);
        text(Y(i),X(i),num2str(i));
    end
%% 
% computing the test statistics T
 T=v'*W5*v

 if (T<47.6 & T >16.1680)
  disp('Accept the null hypothesis')
else
  disp('Reject the null hypothesis')
 end   

%Computing the standard deviation of the residuals
 
 
   vmean= (sum(v))/55;
  vsq= power(v-vmean,2);
Sd = sqrt((sum(vsq))/55);
%  Outlier detection by method of outliers
for jj= 1:length(v);
  if (v(jj) <= 3*Sd)
    p(jj) = 1;
  elseif (v(jj) > 3*Sd)
    p(jj) = exp(-v(jj));
  end
end



##### SOURCE END #####
--></body></html>